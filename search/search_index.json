{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf1f basefloW","text":""},{"location":"#introduction","title":"Introduction","text":"<p>baseflow is a Python package that provides a collection of functions for baseflow separation, which is the process of separating the baseflow component from the total streamflow.</p> <p>This project is funded by CIROH and aims to extend the functionality of the original baseflow package by adding new features and improvements. Our goal is to continuously enhance and maintain this package, keeping it up-to-date with the latest developments in baseflow separation techniques.</p> <p>\ud83d\udd25 Our GitHub</p>"},{"location":"#project-structure","title":"Project Structure","text":"<p>\u251c\u2500\u2500 methods &lt;- implements for 12 baseflow separation methods \u2502   \u251c\u2500\u2500 separation &lt;- compute baseflow and compare different separation methods \u2502   \u251c\u2500\u2500 param_estimate &lt;- estimates recession coefficient &amp; backward and calibration approaches to estimate other parameters  \u2502 \u251c\u2500\u2500 comparison &lt;- an evaluation criterion to compare different methods (KGE) &amp; compute strict baseflow \u2502   \u2514\u2500\u2500 utils &lt;- helper functions</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#baseflow.separation.boughton","title":"<code>boughton(Q, a, C, initial_method='Q0', return_exceed=False)</code>","text":"<p>Boughton doulbe-parameter filter (Boughton, 2004) Boughton W.C. (1993) - A hydrograph-based model for estimating water yield of ungauged catchments. Institute of Engineers Australia National Conference. Publ. 93/14, pp. 317-324.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>C</code> <code>float</code> <p>calibrated in baseflow.param_estimate</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the baseflow exceeds the streamflow.</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def boughton(Q, a, C, initial_method='Q0', return_exceed=False):\n    \"\"\"Boughton doulbe-parameter filter (Boughton, 2004)\n    Boughton W.C. (1993) - A hydrograph-based model for estimating water yield of ungauged catchments. Institute of Engineers Australia National Conference. Publ. 93/14, pp. 317-324.\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        C (float): calibrated in baseflow.param_estimate\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n            baseflow exceeds the streamflow.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = a / (1 + C) * b[i] + C / (1 + C) * Q[i + 1]\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.chapman","title":"<code>chapman(Q, a, initial_method='Q0', return_exceed=False)</code>","text":"<p>Chapman filter (Chapman, 1991) Chapman, Tom G. \"Comment on 'Evaluation of Automated Techniques for Base Flow and Recession Analyses' by R. J. Nathan and T. A. McMahon.\" Water Resources Research 27, no. 7 (1991): 1783\u201384. https://doi.org/10.1029/91WR01007.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the baseflow exceeds the streamflow.</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def chapman(Q, a, initial_method='Q0', return_exceed=False):\n    \"\"\"Chapman filter (Chapman, 1991)\n    Chapman, Tom G. \"Comment on 'Evaluation of Automated Techniques for Base Flow and Recession Analyses' by R. J. Nathan and T. A. McMahon.\" Water Resources Research 27, no. 7 (1991): 1783\u201384. https://doi.org/10.1029/91WR01007.\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n            baseflow exceeds the streamflow.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = (3 * a - 1) / (3 - a) * b[i] + (1 - a) / (3 - a) * (Q[i + 1] + Q[i])\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.chapman_maxwell","title":"<code>chapman_maxwell(Q, a, initial_method='Q0', return_exceed=False)</code>","text":"<p>CM filter (Chapman &amp; Maxwell, 1996) Chapman, T. G., Maxwell, A. I. (1996) - Baseflow separation - comparison of numerical methods with tracer experiments, in Hydrol. and Water Resour. Symp., Institution of Engineers Australia, Hobart. pp. 539-545.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be oythoprovided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> Source code in <code>baseflow/separation.py</code> <pre><code>def chapman_maxwell(Q, a, initial_method='Q0' , return_exceed=False):\n    \"\"\"CM filter (Chapman &amp; Maxwell, 1996)\n    Chapman, T. G., Maxwell, A. I. (1996) - Baseflow separation - comparison of numerical methods with tracer experiments, in Hydrol. and Water Resour. Symp., Institution of Engineers Australia, Hobart. pp. 539-545.\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be oythoprovided to directly set the initial baseflow value.\n            Default is 'Q0'.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n   # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = a / (2 - a) * b[i] + (1 - a) / (2 - a) * Q[i + 1]\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.eckhardt","title":"<code>eckhardt(Q, a, BFImax, initial_method='Q0', return_exceed=False)</code>","text":"<p>Eckhardt filter (Eckhardt, 2005) Eckhardt, K. \u201cHow to Construct Recursive Digital Filters for Baseflow Separation.\u201d Hydrological Processes 19, no. 2 (2005): 507\u201315. https://doi.org/10.1002/hyp.5675.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>BFImax</code> <code>float</code> <p>maximum value of baseflow index (BFI)</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def eckhardt(Q, a, BFImax, initial_method='Q0', return_exceed=False):\n    \"\"\"Eckhardt filter (Eckhardt, 2005)\n    Eckhardt, K. \u201cHow to Construct Recursive Digital Filters for Baseflow Separation.\u201d Hydrological Processes 19, no. 2 (2005): 507\u201315. https://doi.org/10.1002/hyp.5675.\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        BFImax (float): maximum value of baseflow index (BFI)\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n   # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = ((1 - BFImax) * a * b[i] + (1 - a) * BFImax * Q[i + 1]) / (1 - a * BFImax)\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.ewma","title":"<code>ewma(Q, e, initial_method='Q0', return_exceed=False)</code>","text":"<p>exponential weighted moving average (EWMA) filter (Tularam &amp; Ilahee, 2008) Tularam, Gurudeo Anand, and Mahbub Ilahee. \u201cExponential Smoothing Method of Base Flow Separation and Its Impact on Continuous Loss Estimates.\u201d American Journal of Environmental Sciences 4, no. 2 (April 30, 2008): 136\u201344. https://doi.org/10.3844/ajessp.2008.136.144.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>e</code> <code>float</code> <p>smoothing parameter</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def ewma(Q, e, initial_method='Q0', return_exceed=False):\n    \"\"\"exponential weighted moving average (EWMA) filter (Tularam &amp; Ilahee, 2008)\n    Tularam, Gurudeo Anand, and Mahbub Ilahee. \u201cExponential Smoothing Method of Base Flow Separation and Its Impact on Continuous Loss Estimates.\u201d American Journal of Environmental Sciences 4, no. 2 (April 30, 2008): 136\u201344. https://doi.org/10.3844/ajessp.2008.136.144.\n\n    Args:\n        Q (np.array): streamflow\n        e (float): smoothing parameter\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = (1 - e) * b[i] + e * Q[i + 1]\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.fixed","title":"<code>fixed(Q, area=None)</code>","text":"<p>Fixed interval graphical method from HYSEP program (Sloto &amp; Crouse, 1996) Sloto, R. A., &amp; Crouse, M. Y. (1996). HYSEP: A Computer Program for Streamflow Hydrograph Separation and Analysis (96-4040). Reston, VA: U.S. Geological Survey. https://doi.org/10.3133/wri964040.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>area</code> <code>float</code> <p>basin area in km^2</p> <code>None</code> Source code in <code>baseflow/separation.py</code> <pre><code>def fixed(Q, area=None):\n    \"\"\"Fixed interval graphical method from HYSEP program (Sloto &amp; Crouse, 1996)\n    Sloto, R. A., &amp; Crouse, M. Y. (1996). HYSEP: A Computer Program for Streamflow Hydrograph Separation and Analysis (96-4040). Reston, VA: U.S. Geological Survey. https://doi.org/10.3133/wri964040.\n\n    Args:\n        Q (np.array): streamflow\n        area (float): basin area in km^2\n    \"\"\"\n    inN = hysep_interval(area)\n    return fixed_interpolation(Q, inN)\n</code></pre>"},{"location":"api/#baseflow.separation.furey","title":"<code>furey(Q, a, A, initial_method='Q0', return_exceed=False)</code>","text":"<p>Furey digital filter (Furey &amp; Gupta, 2001, 2003) Furey, Peter R., and Vijay K. Gupta. \u201cA Physically Based Filter for Separating Base Flow from Streamflow Time Series.\u201d Water Resources Research 37, no. 11 (2001): 2709\u201322. https://doi.org/10.1029/2001WR000243.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>A</code> <code>float</code> <p>calibrated in baseflow.param_estimate</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the baseflow exceeds the streamflow.</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def furey(Q, a, A, initial_method='Q0', return_exceed=False):\n    \"\"\"Furey digital filter (Furey &amp; Gupta, 2001, 2003)\n    Furey, Peter R., and Vijay K. Gupta. \u201cA Physically Based Filter for Separating Base Flow from Streamflow Time Series.\u201d Water Resources Research 37, no. 11 (2001): 2709\u201322. https://doi.org/10.1029/2001WR000243.\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        A (float): calibrated in baseflow.param_estimate\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n            baseflow exceeds the streamflow.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = (a - A * (1 - a)) * b[i] + A * (1 - a) * Q[i]\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.hyd_run","title":"<code>hyd_run(streamflow, k=0.9, passes=4)</code>","text":"<p>Separates baseflow from a streamflow hydrograph using a digital filter method.</p> <p>Parameters:</p> Name Type Description Default <code>streamflow</code> <code>ndarray</code> <p>A numpy array of streamflow values in chronological order.</p> required <code>k</code> <code>float</code> <p>A filter coefficient between 0 and 1 (typically 0.9). Defaults to 0.9.</p> <code>0.9</code> <code>passes</code> <code>int</code> <p>Number of times the filter passes through the data (typically 4). Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <p>numpy.ndarray: A numpy array of baseflow values.</p> Example <p>import numpy as np streamflow = np.array([10, 15, 20, 18, 12]) baseflow = hyd_run(streamflow) print(baseflow) [10.         10.90909091 13.27272727 15.18181818 14.36363636]</p> Source code in <code>baseflow/separation.py</code> <pre><code>def hyd_run(streamflow, k=0.9, passes=4):\n    \"\"\"\n    Separates baseflow from a streamflow hydrograph using a digital filter method.\n\n    Args:\n        streamflow (numpy.ndarray): A numpy array of streamflow values in chronological order.\n        k (float, optional): A filter coefficient between 0 and 1 (typically 0.9). Defaults to 0.9.\n        passes (int, optional): Number of times the filter passes through the data (typically 4). Defaults to 4.\n\n    Returns:\n        numpy.ndarray: A numpy array of baseflow values.\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; streamflow = np.array([10, 15, 20, 18, 12])\n        &gt;&gt;&gt; baseflow = hyd_run(streamflow)\n        &gt;&gt;&gt; print(baseflow)\n        [10.         10.90909091 13.27272727 15.18181818 14.36363636]\n    \"\"\"\n    # Convert to numpy array and handle NaN values\n    Q = np.array(streamflow)\n    Q = Q[~np.isnan(Q)]\n\n    # Initialize baseflow list\n    baseflow = np.zeros_like(Q)\n    baseflow[0] = Q[0]  # Set first baseflow value to first streamflow value\n\n    for p in range(1, passes + 1):\n        # Forward and backward pass\n        if p % 2 == 1:\n            start, end, step = 0, len(Q), 1\n        else:\n            start, end, step = len(Q) - 1, -1, -1\n\n        for i in range(start + step, end, step):\n            tmp = k * baseflow[i - step] + (1 - k) * (Q[i] + Q[i - step]) / 2\n            baseflow[i] = min(tmp, Q[i])\n\n    return baseflow\n</code></pre>"},{"location":"api/#baseflow.separation.lh","title":"<code>lh(Q, beta=0.925, return_exceed=False)</code>","text":"<p>LH digital filter (Lyne &amp; Hollick, 1979) Lyne, V. and Hollick, M. (1979) Stochastic Time-Variable Rainfall-Runoff Modeling. Institute of Engineers Australia National Conference, 89-93.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>beta</code> <code>float</code> <p>filter parameter, 0.925 recommended by (Nathan &amp; McMahon, 1990)</p> <code>0.925</code> Source code in <code>baseflow/separation.py</code> <pre><code>def lh(Q, beta=0.925, return_exceed=False):\n    \"\"\"LH digital filter (Lyne &amp; Hollick, 1979)\n    Lyne, V. and Hollick, M. (1979) Stochastic Time-Variable Rainfall-Runoff Modeling. Institute of Engineers Australia National Conference, 89-93.\n\n    Args:\n        Q (np.array): streamflow\n        beta (float): filter parameter, 0.925 recommended by (Nathan &amp; McMahon, 1990)\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # first pass\n    b[0] = Q[0]\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = beta * b[i] + (1 - beta) / 2 * (Q[i] + Q[i + 1])\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n\n    # second pass\n    b1 = np.copy(b)\n    for i in range(Q.shape[0] - 2, -1, -1):\n        b[i] = beta * b[i + 1] + (1 - beta) / 2 * (b1[i + 1] + b1[i])\n        if b[i] &gt; b1[i]:\n            b[i] = b1[i]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.lh_multi","title":"<code>lh_multi(Q, beta=0.925, num_pass=2, return_exceed=False)</code>","text":"<p>Applies a low-pass filter to the input time series <code>Q</code> using the Lyne-Hollick (LH) recursive digital filter.</p> <p>The filter is applied in multiple passes, with the number of passes controlled by the <code>num_pass</code> parameter. The filter uses a smoothing parameter <code>beta</code> to control the degree of filtering.</p> <p>Spongberg, M. E. \u201cSpectral Analysis of Base Flow Separation with Digital Filters.\u201d Water Resources Research 36, no. 3 (2000): 745\u201352. https://doi.org/10.1029/1999WR900303.</p> <p>If <code>return_exceed</code> is True, the function will also return the number of times the filtered output <code>b</code> exceeds the original input <code>Q</code>.</p> <p>Lyne, V. and Hollick, M. (1979) Stochastic Time-Variable Rainfall-Runoff Modeling. Institute of Engineers Australia National Conference, 89-93. </p> <p>Spongberg, M. E. \u201cSpectral Analysis of Base Flow Separation with Digital Filters.\u201d Water Resources Research 36, no. 3 (2000): 745\u201352. https://doi.org/10.1029/1999WR900303.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>ndarray</code> <p>The input time series to be filtered.</p> required <code>beta</code> <code>float</code> <p>The smoothing parameter for the LH filter, between 0 and 1. Defaults to 0.925.</p> <code>0.925</code> <code>num_pass</code> <code>int</code> <p>The number of filter passes to apply. Defaults to 2.</p> <code>2</code> <code>return_exceed</code> <code>bool</code> <p>If True, the function will return the number of times the filtered output exceeds the original input. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <p>numpy.ndarray: The filtered output time series.</p> <code>int</code> <code>optional</code> <p>The number of times the filtered output exceeds the original input, if <code>return_exceed</code> is True.</p> Source code in <code>baseflow/separation.py</code> <pre><code>def lh_multi(Q, beta=0.925, num_pass=2, return_exceed=False):\n    \"\"\"\n    Applies a low-pass filter to the input time series `Q` using the Lyne-Hollick (LH) recursive digital filter.\n\n    The filter is applied in multiple passes, with the number of passes controlled by the `num_pass` parameter. The filter uses a smoothing parameter `beta` to control the degree of filtering.\n\n    Spongberg, M. E. \u201cSpectral Analysis of Base Flow Separation with Digital Filters.\u201d Water Resources Research 36, no. 3 (2000): 745\u201352. https://doi.org/10.1029/1999WR900303.\n\n    If `return_exceed` is True, the function will also return the number of times the filtered output `b` exceeds the original input `Q`.\n\n    Lyne, V. and Hollick, M. (1979) Stochastic Time-Variable Rainfall-Runoff Modeling. Institute of Engineers Australia National Conference, 89-93. \n\n    Spongberg, M. E. \u201cSpectral Analysis of Base Flow Separation with Digital Filters.\u201d Water Resources Research 36, no. 3 (2000): 745\u201352. https://doi.org/10.1029/1999WR900303.\n\n    Args:\n        Q (numpy.ndarray): The input time series to be filtered.\n        beta (float, optional): The smoothing parameter for the LH filter, between 0 and 1. Defaults to 0.925.\n        num_pass (int, optional): The number of filter passes to apply. Defaults to 2.\n        return_exceed (bool, optional): If True, the function will return the number of times the filtered output exceeds the original input. Defaults to False.\n\n    Returns:\n        numpy.ndarray: The filtered output time series.\n        int (optional): The number of times the filtered output exceeds the original input, if `return_exceed` is True.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    b[0] = Q[0]\n\n    for n in range(num_pass):\n        if n != 0:\n            b = np.flip(b, axis=0)\n            Q = b.copy()\n\n        for i in range(Q.shape[0] - 1):\n            b[i + 1] = beta * b[i] + (1 - beta) / 2 * (Q[i] + Q[i + 1])\n            if b[i + 1] &gt; Q[i + 1]:\n                b[i + 1] = Q[i + 1]\n                if return_exceed:\n                    b[-1] += 1\n\n    if num_pass % 2 == 0:\n        b = np.flip(b, axis=0)\n\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.local","title":"<code>local(Q, b_LH, area=None, return_exceed=False)</code>","text":"<p>Local minimum graphical method from HYSEP program (Sloto &amp; Crouse, 1996)</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>area</code> <code>float</code> <p>basin area in km^2</p> <code>None</code> Source code in <code>baseflow/separation.py</code> <pre><code>def local(Q, b_LH, area=None, return_exceed=False):\n    \"\"\"Local minimum graphical method from HYSEP program (Sloto &amp; Crouse, 1996)\n\n    Args:\n        Q (np.array): streamflow\n        area (float): basin area in km^2\n    \"\"\"\n    idx_turn = local_turn(Q, hysep_interval(area))\n    if idx_turn.shape[0] &lt; 3:\n        raise IndexError('Less than 3 turning points found')\n    b = linear_interpolation(Q, idx_turn, return_exceed=return_exceed)\n    b[:idx_turn[0]] = b_LH[:idx_turn[0]]\n    b[idx_turn[-1] + 1:] = b_LH[idx_turn[-1] + 1:]\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.single_station","title":"<code>single_station(series, area=None, ice=None, method='all')</code>","text":"<p>Perform baseflow separation on a given streamflow time series using various methods.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The streamflow time series to perform baseflow separation on.</p> required <code>area</code> <code>float</code> <p>The drainage area of the streamflow station, used for some methods.</p> <code>None</code> <code>ice</code> <code>ndarray or tuple</code> <p>A boolean array or a tuple of start and end months indicating the ice-affected period.</p> <code>None</code> <code>method</code> <code>str or list</code> <p>The baseflow separation method(s) to use. Can be a single method name or a list of method names. Accepted string values are: - 'CM': Chapman and Manning (1985) - 'Boughton': Boughton and Eckhardt (1987) - 'Furey': Furey and Willems (1989) - 'Willems': Willems (1991) - 'UKIH': UKI-Hydro (2000) - 'Local': Local method (2009) - 'all': All methods. Default is 'all'.</p> <code>'all'</code> <p>Returns:     pandas.DataFrame: A DataFrame containing the baseflow time series for each method.</p> Source code in <code>baseflow/separation.py</code> <pre><code>def single_station(series, area=None, ice=None, method='all'):\n    \"\"\"\n    Perform baseflow separation on a given streamflow time series using various methods.\n\n    Args:\n        series (pandas.Series): The streamflow time series to perform baseflow separation on.\n        area (float, optional): The drainage area of the streamflow station, used for some methods.\n        ice (numpy.ndarray or tuple, optional): A boolean array or a tuple of start and end months indicating the ice-affected period.\n        method (str or list, optional): The baseflow separation method(s) to use. Can be a single method name or a list of method names.\n            Accepted string values are:\n            - 'CM': Chapman and Manning (1985)\n            - 'Boughton': Boughton and Eckhardt (1987)\n            - 'Furey': Furey and Willems (1989)\n            - 'Willems': Willems (1991)\n            - 'UKIH': UKI-Hydro (2000)\n            - 'Local': Local method (2009)\n            - 'all': All methods.\n            Default is 'all'.\n    Returns:\n        pandas.DataFrame: A DataFrame containing the baseflow time series for each method.\n        \"\"\"\n    Q, date = clean_streamflow(series)\n    method = format_method(method)\n\n    # convert ice_period ([11, 1], [3, 31]) to bool array\n    if not isinstance(ice, np.ndarray) or ice.shape[0] == 12:\n        ice = exist_ice(date, ice)\n    strict = strict_baseflow(Q, ice)\n    if any(m in ['Chapman', 'CM', 'Boughton', 'Furey', 'Eckhardt', 'Willems'] for m in method):\n        a = recession_coefficient(Q, strict)\n\n    b_LH = lh(Q)\n    b = pd.DataFrame(np.nan, index=date, columns=method)\n    for m in method:\n        if m == 'UKIH':\n            b[m] = ukih(Q, b_LH)\n\n        if m == 'Local':\n            b[m] = local(Q, b_LH, area)\n\n        if m == 'Fixed':\n            b[m] = fixed(Q, area)\n\n        if m == 'Slide':\n            b[m] = slide(Q, area)\n\n        if m == 'LH':\n            b[m] = b_LH\n\n        if m == 'Chapman':\n            b[m] = chapman(Q, b_LH, a)\n\n        if m == 'CM':\n            b[m] = chapman_maxwell(Q, b_LH, a)\n\n        if m == 'Boughton':\n            C = param_calibrate(np.arange(0.0001, 0.1, 0.0001), boughton, Q, b_LH, a)\n            b[m] = boughton(Q, b_LH, a, C)\n\n        if m == 'Furey':\n            A = param_calibrate(np.arange(0.01, 10, 0.01), furey, Q, b_LH, a)\n            b[m] = furey(Q, b_LH, a, A)\n\n        if m == 'Eckhardt':\n            # BFImax = maxmium_BFI(Q, b_LH, a, date)\n            BFImax = param_calibrate(np.arange(0.001, 1, 0.001), eckhardt, Q, b_LH, a)\n            b[m] = eckhardt(Q, b_LH, a, BFImax)\n\n        if m == 'EWMA':\n            e = param_calibrate(np.arange(0.0001, 0.1, 0.0001), ewma, Q, b_LH, 0)\n            b[m] = ewma(Q, b_LH, 0, e)\n\n        if m == 'Willems':\n            w = param_calibrate(np.arange(0.001, 1, 0.001), willems, Q, b_LH, a)\n            b[m] = willems(Q, b_LH, a, w)\n\n        return b\n</code></pre>"},{"location":"api/#baseflow.separation.slide","title":"<code>slide(Q, area)</code>","text":"<p>Slide interval graphical method from HYSEP program (Sloto &amp; Crouse, 1996) Sloto, R. A., &amp; Crouse, M. Y. (1996). HYSEP: A Computer Program for Streamflow Hydrograph Separation and Analysis (96-4040). Reston, VA: U.S. Geological Survey. https://doi.org/10.3133/wri964040.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>area</code> <code>float</code> <p>basin area in km^2</p> required Source code in <code>baseflow/separation.py</code> <pre><code>def slide(Q, area):\n    \"\"\"Slide interval graphical method from HYSEP program (Sloto &amp; Crouse, 1996)\n    Sloto, R. A., &amp; Crouse, M. Y. (1996). HYSEP: A Computer Program for Streamflow Hydrograph Separation and Analysis (96-4040). Reston, VA: U.S. Geological Survey. https://doi.org/10.3133/wri964040.\n\n    Args:\n        Q (np.array): streamflow\n        area (float): basin area in km^2\n    \"\"\"\n    inN = hysep_interval(area)\n    return slide_interpolation(Q, inN)\n</code></pre>"},{"location":"api/#baseflow.separation.ukih","title":"<code>ukih(Q, b_LH, return_exceed=False)</code>","text":"<p>graphical method developed by UK Institute of Hydrology (UKIH, 1980) Aksoy, Hafzullah, Ilker Kurt, and Ebru Eris. \u201cFiltered Smoothed Minima Baseflow Separation Method.\u201d Journal of Hydrology 372, no. 1 (June 15, 2009): 94\u2013101. https://doi.org/10.1016/j.jhydrol.2009.03.037.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the baseflow exceeds the streamflow.</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def ukih(Q, b_LH, return_exceed=False):\n    \"\"\"graphical method developed by UK Institute of Hydrology (UKIH, 1980)\n    Aksoy, Hafzullah, Ilker Kurt, and Ebru Eris. \u201cFiltered Smoothed Minima Baseflow Separation Method.\u201d Journal of Hydrology 372, no. 1 (June 15, 2009): 94\u2013101. https://doi.org/10.1016/j.jhydrol.2009.03.037.\n\n    Args:\n        Q (np.array): streamflow\n        return_exceed (bool, optional): if True, returns the number of times the\n            baseflow exceeds the streamflow.\n    \"\"\"\n    N = 5\n    block_end = Q.shape[0] // N * N\n    idx_min = np.argmin(Q[:block_end].reshape(-1, N), axis=1)\n    idx_min = idx_min + np.arange(0, block_end, N)\n    idx_turn = ukih_turn(Q, idx_min)\n    if idx_turn.shape[0] &lt; 3:\n        raise IndexError('Less than 3 turning points found')\n    b = linear_interpolation(Q, idx_turn, return_exceed=return_exceed)\n    b[:idx_turn[0]] = b_LH[:idx_turn[0]]\n    b[idx_turn[-1] + 1:] = b_LH[idx_turn[-1] + 1:]\n    return b\n</code></pre>"},{"location":"api/#baseflow.separation.what","title":"<code>what(streamflow, BFImax, alpha)</code>","text":"<p>Separates baseflow and quickflow from a streamflow time series using the WHAT method.</p> <p>Parameters:</p> Name Type Description Default <code>streamflow</code> <code>ndarray</code> <p>A numpy array of streamflow values.</p> required <code>BFImax</code> <code>float</code> <p>The maximum baseflow index (BFI) value.</p> required <code>alpha</code> <code>float</code> <p>A filter parameter.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing two numpy arrays: baseflow and quickflow.</p> Example <p>import numpy as np streamflow = np.array([10, 15, 20, 18, 12]) baseflow, quickflow = what(streamflow, 0.8, 0.98) print(baseflow) [ 9.8         12.74        15.68        16.544       15.3712    ] print(quickflow) [ 0.2          2.26         4.32         1.456       -3.3712    ]</p> Source code in <code>baseflow/separation.py</code> <pre><code>def what(streamflow, BFImax, alpha):\n    \"\"\"\n    Separates baseflow and quickflow from a streamflow time series using the WHAT method.\n\n    Args:\n        streamflow (numpy.ndarray): A numpy array of streamflow values.\n        BFImax (float): The maximum baseflow index (BFI) value.\n        alpha (float): A filter parameter.\n\n    Returns:\n        tuple: A tuple containing two numpy arrays: baseflow and quickflow.\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; streamflow = np.array([10, 15, 20, 18, 12])\n        &gt;&gt;&gt; baseflow, quickflow = what(streamflow, 0.8, 0.98)\n        &gt;&gt;&gt; print(baseflow)\n        [ 9.8         12.74        15.68        16.544       15.3712    ]\n        &gt;&gt;&gt; print(quickflow)\n        [ 0.2          2.26         4.32         1.456       -3.3712    ]\n    \"\"\"\n    baseflow = np.zeros_like(streamflow)\n\n    for t in range(1, len(streamflow)):\n        baseflow[t] = ((1 - BFImax) * alpha * baseflow[t-1] + (1 - alpha) * BFImax * streamflow[t]) / (1 - alpha * BFImax)\n\n    quickflow = streamflow - baseflow\n\n    return baseflow\n</code></pre>"},{"location":"api/#baseflow.separation.willems","title":"<code>willems(Q, a, w, initial_method='Q0', return_exceed=False)</code>","text":"<p>digital filter (Willems, 2009)</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>array</code> <p>streamflow</p> required <code>a</code> <code>float</code> <p>recession coefficient</p> required <code>w</code> <code>float</code> <p>case-speci\ufb01c average proportion of the quick \ufb02ow        in the streamflow, calibrated in baseflow.param_estimate</p> required <code>initial_method</code> <code>str or float</code> <p>method to calculate the initial baseflow value. Accepted string values are: - 'Q0': Use Q[0] as the initial baseflow value. - 'min': Use np.min(Q) as the initial baseflow value. - 'LH': Calculate the initial baseflow value using the LH method. Alternatively, a float value can be provided to directly set the initial baseflow value. Default is 'Q0'.</p> <code>'Q0'</code> <code>return_exceed</code> <code>bool</code> <p>if True, returns the number of times the baseflow exceeds the streamflow.</p> <code>False</code> Source code in <code>baseflow/separation.py</code> <pre><code>def willems(Q, a, w, initial_method='Q0', return_exceed=False):\n    \"\"\"digital filter (Willems, 2009)\n\n    Args:\n        Q (np.array): streamflow\n        a (float): recession coefficient\n        w (float): case-speci\ufb01c average proportion of the quick \ufb02ow\n                   in the streamflow, calibrated in baseflow.param_estimate\n        initial_method (str or float, optional): method to calculate the initial baseflow value.\n            Accepted string values are:\n            - 'Q0': Use Q[0] as the initial baseflow value.\n            - 'min': Use np.min(Q) as the initial baseflow value.\n            - 'LH': Calculate the initial baseflow value using the LH method.\n            Alternatively, a float value can be provided to directly set the initial baseflow value.\n            Default is 'Q0'.\n        return_exceed (bool, optional): if True, returns the number of times the\n            baseflow exceeds the streamflow.\n    \"\"\"\n    if return_exceed:\n        b = np.zeros(Q.shape[0] + 1)\n    else:\n        b = np.zeros(Q.shape[0])\n\n    # Set initial value for b based on the specified method\n    if isinstance(initial_method, str):\n        if initial_method == 'Q0':\n            b[0] = Q[0]\n        elif initial_method == 'min':\n            b[0] = np.min(Q)\n        elif initial_method == 'LH':\n            b[0] = lh(Q)[0]  # Calculate the initial value using the LH method\n        else:\n            raise ValueError(f\"Invalid initial_method: {initial_method}\")\n    else:\n        b[0] = initial_method\n\n    v = (1 - w) * (1 - a) / (2 * w)\n    for i in range(Q.shape[0] - 1):\n        b[i + 1] = (a - v) / (1 + v) * b[i] + v / (1 + v) * (Q[i] + Q[i + 1])\n        if b[i + 1] &gt; Q[i + 1]:\n            b[i + 1] = Q[i + 1]\n            if return_exceed:\n                b[-1] += 1\n    return b\n</code></pre>"},{"location":"instructions/","title":"Instructions","text":""},{"location":"instructions/#tutorials","title":"Tutorials","text":""},{"location":"instructions/#basic-tutorial","title":"Basic Tutorial","text":"<p>We have developed a Python package named <code>baseflow</code> that provides tools for baseflow separation. This package is available on PyPI and can be easily installed using pip:</p> <pre><code>pip install baseflow\n</code></pre>"},{"location":"instructions/#interactive-api-examples","title":"Interactive API Examples","text":"<p>To help you get started with the baseflow package, we have created a Colab notebook that demonstrates its usage. The notebook includes the following content:</p> <ul> <li>Introduction: An overview of baseflow separation and the purpose of the baseflow package.</li> <li>Installation: Instructions on how to install the baseflow package in the Colab environment.</li> <li>Basic Usage: Examples of how to use the main functions of the baseflow package to perform baseflow separation on sample data.</li> <li>Advanced Features: Demonstrations of advanced features and customization options available in the baseflow package.</li> <li>Visualization: Techniques for visualizing the results of baseflow separation using popular Python libraries such as Matplotlib.</li> </ul> <p>\ud83d\udd25 You can access the Colab notebook here: \u2b07\ufe0f</p> <p>Note</p> <p>You may wish to make a copy of the notebook in your own Google Drive.</p> <p>Tip</p> <p>Run each cell of the notebook by hitting the play button on the left side of each cell and provide the necessary inputs.The notebook is divided into multiple sections and each section contains a set of cells, each of which contains Python code. When you first launch the notebook, the sections are collapsed and you need to expand each section to view and run the code.</p> <p>We hope this notebook helps you understand how to effectively use the baseflow package for your baseflow separation needs.</p>"},{"location":"utils/","title":"API Reference","text":""},{"location":"utils/#baseflow.utils.clean_streamflow","title":"<code>clean_streamflow(series)</code>","text":"<p>Cleans a streamflow time series by removing invalid values and keeping only years with at least 120 data points.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The streamflow time series to be cleaned.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the cleaned streamflow values and the corresponding dates.</p> Source code in <code>baseflow/utils.py</code> <pre><code>def clean_streamflow(series):\n    \"\"\"\n    Cleans a streamflow time series by removing invalid values and keeping only years with at least 120 data points.\n\n    Args:\n        series (pandas.Series): The streamflow time series to be cleaned.\n\n    Returns:\n        tuple: A tuple containing the cleaned streamflow values and the corresponding dates.\n    \"\"\"\n    date, Q = series.index, series.values.astype(float)\n    has_value = np.isfinite(Q)\n    date, Q = date[has_value], np.abs(Q[has_value])\n    year_unique, counts = np.unique(date.year, return_counts=True)\n    keep = np.isin(date.year, year_unique[counts &gt;= 120])\n    return Q[keep], date[keep]\n</code></pre>"},{"location":"utils/#baseflow.utils.exist_ice","title":"<code>exist_ice(date, ice_period)</code>","text":"<p>Checks if a given date falls within an ice period.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>datetime</code> <p>The date to check.</p> required <code>ice_period</code> <code>tuple or ndarray</code> <p>The ice period, either as a tuple of (start_month, start_day, end_month, end_day) or as a numpy array of months.</p> required <p>Returns:</p> Type Description <p>bool or numpy.ndarray: True if the date falls within the ice period, False otherwise. If <code>ice_period</code> is a numpy array, the return value will be a numpy array of the same shape.</p> Source code in <code>baseflow/utils.py</code> <pre><code>def exist_ice(date, ice_period):\n    \"\"\"\n    Checks if a given date falls within an ice period.\n\n    Args:\n        date (datetime.datetime): The date to check.\n        ice_period (tuple or numpy.ndarray): The ice period, either as a tuple of (start_month, start_day, end_month, end_day) or as a numpy array of months.\n\n    Returns:\n        bool or numpy.ndarray: True if the date falls within the ice period, False otherwise. If `ice_period` is a numpy array, the return value will be a numpy array of the same shape.\n    \"\"\"\n    if (date is None) or (ice_period is None):\n        return None\n\n    if isinstance(ice_period, np.ndarray):\n        return np.isin(date.month, np.where(ice_period)[0] + 1)\n\n    beg, end = ice_period\n    if (end[0] &gt; beg[0]) or ((end[0] == beg[0]) &amp; (end[1] &gt; beg[1])):\n        ice = (((date.month &gt; beg[0]) &amp; (date.month &lt; end[0])) |\n               ((date.month == beg[0]) &amp; (date.day &gt;= beg[1])) |\n               ((date.month == end[0]) &amp; (date.day &lt;= end[1])))\n    else:\n        ice = (((date.month &gt; beg[0]) | (date.month &lt; end[0])) |\n               ((date.month == beg[0]) &amp; (date.day &gt;= beg[1])) |\n               ((date.month == end[0]) &amp; (date.day &lt;= end[1])))\n    return ice\n</code></pre>"},{"location":"utils/#baseflow.utils.format_method","title":"<code>format_method(method)</code>","text":"<p>Formats the input method parameter to a list of method names.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str or list</code> <p>The input method parameter, which can be a single string or a list of strings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of method names.</p> Source code in <code>baseflow/utils.py</code> <pre><code>def format_method(method):\n    \"\"\"\n    Formats the input method parameter to a list of method names.\n\n    Args:\n        method (str or list): The input method parameter, which can be a single string or a list of strings.\n\n    Returns:\n        list: A list of method names.\n    \"\"\"\n    if method == 'all':\n        method = ['UKIH', 'Local', 'Fixed', 'Slide', 'LH', 'Chapman',\n                  'CM', 'Boughton', 'Furey', 'Eckhardt', 'EWMA', 'Willems']\n    elif isinstance(method, str):\n        method = [method]\n    return method\n</code></pre>"},{"location":"utils/#baseflow.utils.geo2imagexy","title":"<code>geo2imagexy(x, y)</code>","text":"<p>Converts geographic coordinates (x, y) to image coordinates (col, row).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate in geographic space.</p> required <code>y</code> <code>float</code> <p>The y-coordinate in geographic space.</p> required <p>Returns:</p> Type Description <p>Tuple[int, int]: The corresponding column and row indices in image space.</p> Source code in <code>baseflow/utils.py</code> <pre><code>def geo2imagexy(x, y):\n    \"\"\"\n    Converts geographic coordinates (x, y) to image coordinates (col, row).\n\n    Args:\n        x (float): The x-coordinate in geographic space.\n        y (float): The y-coordinate in geographic space.\n\n    Returns:\n        Tuple[int, int]: The corresponding column and row indices in image space.\n    \"\"\"\n    a = np.array([[0.5, 0.0], [0.0, -0.5]])\n    b = np.array([x - -180, y - 90])\n    col, row = np.linalg.solve(a, b) - 0.5\n    return np.round(col).astype(int), np.round(row).astype(int)\n</code></pre>"},{"location":"utils/#baseflow.utils.moving_average","title":"<code>moving_average(x, w)</code>","text":"<p>Computes the moving average of the input array <code>x</code> using a window size of <code>w</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input array.</p> required <code>w</code> <code>int</code> <p>The window size for the moving average.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The moving average of the input array <code>x</code>.</p> Source code in <code>baseflow/utils.py</code> <pre><code>def moving_average(x, w):\n    \"\"\"\n    Computes the moving average of the input array `x` using a window size of `w`.\n\n    Args:\n        x (numpy.ndarray): The input array.\n        w (int): The window size for the moving average.\n\n    Returns:\n        numpy.ndarray: The moving average of the input array `x`.\n    \"\"\"\n    res = np.convolve(x, np.ones(w)) / w\n    return res[w - 1:-w + 1]\n</code></pre>"},{"location":"utils/#baseflow.utils.multi_arange","title":"<code>multi_arange(starts, stops)</code>","text":"<p>Generates a 1D numpy array containing all integers between the given start and stop values for each element in the input arrays.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>ndarray</code> <p>A 1D numpy array of start values.</p> required <code>stops</code> <code>ndarray</code> <p>A 1D numpy array of stop values, where each stop value corresponds to the start value at the same index.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: A 1D numpy array containing all integers between the given start and stop values for each element in the input arrays.</p> Source code in <code>baseflow/utils.py</code> <pre><code>@njit\ndef multi_arange(starts, stops):\n    \"\"\"\n    Generates a 1D numpy array containing all integers between the given start and stop values for each element in the input arrays.\n\n    Args:\n        starts (numpy.ndarray): A 1D numpy array of start values.\n        stops (numpy.ndarray): A 1D numpy array of stop values, where each stop value corresponds to the start value at the same index.\n\n    Returns:\n        numpy.ndarray: A 1D numpy array containing all integers between the given start and stop values for each element in the input arrays.\n    \"\"\"\n    pos = 0\n    cnt = np.sum(stops - starts, dtype=np.int64)\n    res = np.zeros((cnt,), dtype=np.int64)\n    for i in range(starts.size):\n        num = stops[i] - starts[i]\n        res[pos:pos + num] = np.arange(starts[i], stops[i])\n        pos += num\n    return res\n</code></pre>"}]}